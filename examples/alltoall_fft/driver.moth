include <mpi>
include <fftw>
#include <timer>
include dfft

def int main(list str argv):

    if argv.len() != 3:
        print("USAGE: ",argv[0]," n_repetitions ngx\n")
        return 0

    mpi.init()

    int Ng = int(argv[2])
    int ntests = int(argv[1])

    object Distribution dist = new Distribution(Ng)
    object Dfft dfft = new Dfft(dist)

    if dist.world_rank == 0:
        print("distribution 3D: ",dist.dims)
        print("Ng: ",Ng,"\n\n")

    double[:,:] buff1 = nm.zeros((dfft.dist.nlocal,2))
    double[:,:] buff2 = nm.zeros((dfft.dist.nlocal,2))

    double[:] minimum
    double[:] maximum
    double start
    double end
    double time
    double mean_time
    double max_time
    double min_time

    dfft.make_plans(buff1,buff2)
    for int i in range(ntests):
        buff1.zero()
        buff2.zero()
        if dfft.dist.world_rank == 0:
            buff1[0,0] = 1
            print("TESTING ",i,"\n\n")

        start = mpi.wtime()

        dfft.forward(buff1,buff2)

        end = mpi.wtime()

        time = end-start

        max_time = mpi.reduce.max(time,mpi.comm_world)
        min_time = mpi.reduce.min(time,mpi.comm_world)
        mean_time = mpi.reduce.sum(time,mpi.comm_world) / dist.world_size

        if dist.world_rank == 0:
            print("FORWARD   max ",max_time,"s  avg: ",mean_time,"s  min ",min_time," s\n\n")

        minimum = buff1.min(0).reshape(2)
        maximum = buff1.max(0).reshape(2)

        float min_real = mpi.reduce.min(minimum[0],mpi.comm_world)
        float max_real = mpi.reduce.max(maximum[0],mpi.comm_world)
        float min_imag = mpi.reduce.min(minimum[1],mpi.comm_world)
        float max_imag = mpi.reduce.max(maximum[1],mpi.comm_world)

        if dist.world_rank == 0:
            print("k-space\n")
            print("real in [",min_real,",",max_real,"]\n")
            print("imag in [",min_imag,",",max_imag,"]\n\n")

        start = mpi.wtime()

        dfft.backward(buff1,buff2)

        end = mpi.wtime()

        time = end-start

        max_time = mpi.reduce.max(time,mpi.comm_world)
        min_time = mpi.reduce.min(time,mpi.comm_world)
        mean_time = mpi.reduce.sum(time,mpi.comm_world) / dist.world_size

        if dist.world_rank == 0:
            print("BACKWARD   max ",max_time,"s  avg: ",mean_time,"s  min ",min_time," s\n\n")

        if dist.world_rank == 0:
            minimum = buff1[1:,:].min(0).reshape(2)
            maximum = buff1[1:,:].max(0).reshape(2)
        else:
            minimum = buff1.min(0).reshape(2)
            maximum = buff1.max(0).reshape(2)

        float min_real = mpi.reduce.min(minimum[0],mpi.comm_world)
        float max_real = mpi.reduce.max(maximum[0],mpi.comm_world)
        float min_imag = mpi.reduce.min(minimum[1],mpi.comm_world)
        float max_imag = mpi.reduce.max(maximum[1],mpi.comm_world)

        if dist.world_rank == 0:
            print("r-space\n")
            print("a[0,0,0] = ",buff1[0,:])
            print("real in [",min_real,",",max_real,"]\n")
            print("imag in [",min_imag,",",max_imag,"]\n\n\n")
        

    dfft.finalize()

    mpi.finalize()

    return 0